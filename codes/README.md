# 2 章　計算量とオーダー記法

- [code 2.1：一重の for 文 (O(N))](https://github.com/drken1215/book_algorithm_solution/blob/master/codes/chap02/code_2_1.cpp)
- [code 2.2：二重の for 文 (O(N^2))](https://github.com/drken1215/book_algorithm_solution/blob/master/codes/chap02/code_2_2.cpp)
- [code 2.3：偶数の列挙](https://github.com/drken1215/book_algorithm_solution/blob/master/codes/chap02/code_2_3.cpp)
- [code 2.4：最近点対問題に対する全探索](https://github.com/drken1215/book_algorithm_solution/blob/master/codes/chap02/code_2_4.cpp)



　

# 3 章　設計技法(1)：全探索

- [code 3.1：線形探索法](https://github.com/drken1215/book_algorithm_solution/blob/master/codes/chap03/code_3_1.cpp)
- [code 3.2：特定の要素の存在する「添字」も取得する](https://github.com/drken1215/book_algorithm_solution/blob/master/codes/chap03/code_3_2.cpp)
- [code 3.3：最小値を求める](https://github.com/drken1215/book_algorithm_solution/blob/master/codes/chap03/code_3_3.cpp) 
- [code 3.6：部分和問題に対するビットを用いる全探索解法](https://github.com/drken1215/book_algorithm_solution/blob/master/codes/chap03/code_3_6.cpp)



　

# 4 章　設計技法(2)：再帰

- [code 4.1：1 から N までの総和を計算する再帰関数](https://github.com/drken1215/book_algorithm_solution/blob/master/codes/chap04/code_4_1.cpp)
- [code 4.2：1 から N までの総和を計算する再帰関数の挙動を見る](https://github.com/drken1215/book_algorithm_solution/blob/master/codes/chap04/code_4_2.cpp)
- [code 4.4：ユークリッドの互除法](https://github.com/drken1215/book_algorithm_solution/blob/master/codes/chap04/code_4_4.cpp)
- [code 4.5：フィボナッチ数列を求める再帰関数](https://github.com/drken1215/book_algorithm_solution/blob/master/codes/chap04/code_4_5.cpp)
- [code 4.6：フィボナッチ数列を求める再帰関数の再帰呼び出しの様子](https://github.com/drken1215/book_algorithm_solution/blob/master/codes/chap04/code_4_6.cpp)
- [code 4.7：フィボナッチ数列を for 文による反復で求める](https://github.com/drken1215/book_algorithm_solution/blob/master/codes/chap04/code_4_7.cpp)
- [code 4.8：フィボナッチ数列を求める再帰関数をメモ化](https://github.com/drken1215/book_algorithm_solution/blob/master/codes/chap04/code_4_8.cpp)
- [code 4.9：部分和問題を再帰関数を用いる全探索で解く](https://github.com/drken1215/book_algorithm_solution/blob/master/codes/chap04/code_4_9.cpp)



　

# 5 章　設計技法(3)：動的計画法

- [code 5.1：Frog 問題を動的計画法で解く](https://github.com/drken1215/book_algorithm_solution/blob/master/codes/chap05/code_5_1.cpp)
- [code 5.2：緩和処理を実現するための関数 chmin](https://github.com/drken1215/book_algorithm_solution/blob/master/codes/chap05/code_5_2.cpp)
- [code 5.3：Frog 問題を「集める遷移形式」で解く](https://github.com/drken1215/book_algorithm_solution/blob/master/codes/chap05/code_5_3.cpp)
- [code 5.4：Frog 問題を「配る遷移形式」で解く](https://github.com/drken1215/book_algorithm_solution/blob/master/codes/chap05/code_5_4.cpp)
- [code 5.6：Frog 問題を「メモ化再帰」で解く](https://github.com/drken1215/book_algorithm_solution/blob/master/codes/chap05/code_5_6.cpp)
- [code 5.7：ナップサック問題](https://github.com/drken1215/book_algorithm_solution/blob/master/codes/chap05/code_5_7.cpp)
- [code 5.8：編集距離](https://github.com/drken1215/book_algorithm_solution/blob/master/codes/chap05/code_5_8.cpp)
- [code 5.9：区間ごとに分割する方法を最適化する](https://github.com/drken1215/book_algorithm_solution/blob/master/codes/chap05/code_5_9.cpp)



　

# 6 章　設計技法(4)：二分探索法

- [code 6.1：配列から目的の値を探索する二分探索法](https://github.com/drken1215/book_algorithm_solution/blob/master/codes/chap06/code_6_1.cpp) 
- [code 6.2：一般化した二分探索法の基本形](https://github.com/drken1215/book_algorithm_solution/blob/master/codes/chap06/code_6_2.cpp) 
- [code 6.3：年齢当てゲームの実装](https://github.com/drken1215/book_algorithm_solution/blob/master/codes/chap06/code_6_3.cpp) 
- [code 6.5：射撃王問題に対する二分探索法](https://github.com/drken1215/book_algorithm_solution/blob/master/codes/chap06/code_6_5.cpp) 



　

# 7 章　設計技法(5)：貪欲法

- [code 7.1：コイン問題を解く貪欲法](https://github.com/drken1215/book_algorithm_solution/blob/master/codes/chap07/code_7_1.cpp) 
- [code 7.2：区間スケジューリング問題に対する貪欲法](https://github.com/drken1215/book_algorithm_solution/blob/master/codes/chap07/code_7_2.cpp) 
- [code 7.3：AtCoder Grand Contest 009 A - Multiple Array の解答例](https://github.com/drken1215/book_algorithm_solution/blob/master/codes/chap07/code_7_3.cpp) 



　

# 8 章　データ構造(1)：配列，連結リスト，ハッシュテーブル

- [code 8.1：配列 (std::vector) の使い方](https://github.com/drken1215/book_algorithm_solution/blob/master/codes/chap08/code_8_1.cpp) 
- [code 8.2：自己参照構造体](https://github.com/drken1215/book_algorithm_solution/blob/master/codes/chap08/code_8_2.cpp) 
- [code 8.4：連結リストを，挿入操作を用いて構築する](https://github.com/drken1215/book_algorithm_solution/blob/master/codes/chap08/code_8_4.cpp) 
- [code 8.5：双方向への自己参照構造体](https://github.com/drken1215/book_algorithm_solution/blob/master/codes/chap08/code_8_5.cpp) 
- [code 8.6；削除操作も可能にした双方向連結リスト](https://github.com/drken1215/book_algorithm_solution/blob/master/codes/chap08/code_8_6.cpp) 



　

# 9 章　データ構造(2)：スタックとキュー

- [code 9.1：スタックの実装](https://github.com/drken1215/book_algorithm_solution/blob/master/codes/chap09/code_9_1.cpp) 
- [code 9.2：キューの実装](https://github.com/drken1215/book_algorithm_solution/blob/master/codes/chap09/code_9_2.cpp) 



　

# 10 章　データ構造(3)：グラフと木

- [code 10.3：グラフを入力として受け取る](https://github.com/drken1215/book_algorithm_solution/blob/master/codes/chap10/code_10_3.cpp) 
- [code 10.4：重み付きグラフの実装](https://github.com/drken1215/book_algorithm_solution/blob/master/codes/chap10/code_10_4.cpp) 
- [code 10.5：ヒープの実装](https://github.com/drken1215/book_algorithm_solution/blob/master/codes/chap10/code_10_5.cpp) 



　

# 11 章　データ構造(4)：Union-Find

- [code 11.1：経路圧縮の工夫なしの場合の根の取得](https://github.com/drken1215/book_algorithm_solution/blob/master/codes/chap11/code_11_1.cpp) 
- [code 11.2：経路圧縮の工夫ありの場合の根の取得](https://github.com/drken1215/book_algorithm_solution/blob/master/codes/chap11/code_11_2.cpp) 
- [code 11.3：Union-Find の実装](https://github.com/drken1215/book_algorithm_solution/blob/master/codes/chap11/code_11_3.cpp) 
- [code 11.4：Union-Find を用いて連結成分の個数を求める](https://github.com/drken1215/book_algorithm_solution/blob/master/codes/chap11/code_11_4.cpp) 



　

# 12 章　ソート

- [code 12.1：挿入ソートの実装](https://github.com/drken1215/book_algorithm_solution/blob/master/codes/chap12/code_12_1.cpp) 
- [code 12.2：マージソートの実装](https://github.com/drken1215/book_algorithm_solution/blob/master/codes/chap12/code_12_2.cpp) 
- [code 12.3：クイックソートの実装](https://github.com/drken1215/book_algorithm_solution/blob/master/codes/chap12/code_12_3.cpp) 
- [code 12.4：ヒープソートの実装](https://github.com/drken1215/book_algorithm_solution/blob/master/codes/chap12/code_12_4.cpp)
- [code 12.5：バケットソートの実装](https://github.com/drken1215/book_algorithm_solution/blob/master/codes/chap12/code_12_5.cpp)  



　

# 13 章　グラフ(1)：グラフ探索

- [code 13.2：再帰関数を用いる深さ優先探索の実装の基本形](https://github.com/drken1215/book_algorithm_solution/blob/master/codes/chap13/code_13_2.cpp)
- [code 13.3：幅優先探索の実装の基本形](https://github.com/drken1215/book_algorithm_solution/blob/master/codes/chap13/code_13_3.cpp)
- [code 13.4：s-t パスがあるかどうかを深さ優先探索を用いて判定](https://github.com/drken1215/book_algorithm_solution/blob/master/codes/chap13/code_13_4.cpp) 
- [code 13.5：二部グラフ判定](https://github.com/drken1215/book_algorithm_solution/blob/master/codes/chap13/code_13_5.cpp) 
- [code 13.6：トポロジカルソート](https://github.com/drken1215/book_algorithm_solution/blob/master/codes/chap13/code_13_6.cpp)
- [code 13.9：根なし木を根付き木にしたときの，各頂点の深さや部分木サイズを求める](https://github.com/drken1215/book_algorithm_solution/blob/master/codes/chap13/code_13_9.cpp)  



　

# 14 章　グラフ(2)：最短路問題

- [code 14.1：緩和に用いる関数 chmin](https://github.com/drken1215/book_algorithm_solution/blob/master/codes/chap14/code_14_1.cpp) 
- [code 14.2：ベルマン・フォード法の実装](https://github.com/drken1215/book_algorithm_solution/blob/master/codes/chap14/code_14_2.cpp) 
- [code 14.3：ダイクストラ法の実装 (ヒープを用いない場合)](https://github.com/drken1215/book_algorithm_solution/blob/master/codes/chap14/code_14_3.cpp) 
- [code 14.4：ダイクストラ法の実装 (ヒープを用いる場合)](https://github.com/drken1215/book_algorithm_solution/blob/master/codes/chap14/code_14_4.cpp) 
- [code 14.5：フロイド・ワーシャル法の実装](https://github.com/drken1215/book_algorithm_solution/blob/master/codes/chap14/code_14_5.cpp) 



　

# 15 章　グラフ(3)：最小全域木問題

- [code 15.1：クラスカル法の実装](https://github.com/drken1215/book_algorithm_solution/blob/master/codes/chap15/code_15_1.cpp) 



　

# 16 章　グラフ(4)：ネットワークフロー

- [code 16.1：フォード・ファルカーソン法の実装](https://github.com/drken1215/book_algorithm_solution/blob/master/codes/chap16/code_16_1.cpp) 



　

# 18 章　難問対策

- [code 18.1：重み付き最大安定集合問題を解く，木上の動的計画法](https://github.com/drken1215/book_algorithm_solution/blob/master/codes/chap18/code_18_1.cpp) 

